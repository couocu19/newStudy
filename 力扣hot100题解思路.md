# 力扣hot100题解思路

### No11 盛水最多的容器

**正确思路：**

 设置开头指针和结尾指针，每次循环都移动二者中的其中一个，我们把数值较大的定为高指针，数值较小的定位低指针，关键：

1.移动高指针，容器的大小只可能不变或者减小；

2.移动低指针，容器的大小可能增大；

所以，每次需要判断哪个是低指针，并移动低指针，知道两个指针相遇，循环结束。



### No24 两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 

**思路记录：**利用栈的后进先出的特点，用一个栈来完成“交换”。首先该方法需要新建一个链表来保存交换后的链表，然后遍历原表，每次遍历两个元素，将其加入栈中，然后再从栈中顶出，每弹出一次就加入到新的链表末尾。





### No27 原地移除元素

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**思路：**

设置**双指针**，i作为待赋值的索引，j用来遍历数组，保证[0,i)中都不含待删元素，即i位置处的元素为待删元素，即待覆盖元素，而覆盖它的数值通过j遍历来确定。

### No 41 缺失的第一个正数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n)，并且只使用常数级别额外空间的解决方案。

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
```

**思路记录：**

常规思路是将所有的元素放入哈希表中，然后从1开始枚举正数，第一个不存在的整数则为缺失的第一个正数。但是这么写的空间复杂度为O（n）,不符合要求。

解决方法的关键在于，要利用现有的数组将其当一个哈希表来用，关键就是，**缺失的第一个正数一定在区间[1,N+1]中**，如果数组中的所有元素正好处于[1，N]中，那么结果就是N+1，反之，缺失的第一个正数一定处于[1,N]中，现在的问题是怎么找到这“第一个”，因为数组的下标为[0,N-1]，并且遍历时也是排好序的，所以只要在遍历元素时，先判断该元素是否在[1,N]中，如果在，则将该元素对应的下标（元素减一）标记为存在。

最后再遍历一遍数组，第一个没被标记的下标加一即为第一个缺失的正数，如果所有下标都访问过了，结果就是N+1。

那么如何标记访问过的下标？

首先将数组中所有元素转为正数，负数用N+1代替即可，然后每访问一个存在于[1,N]中的元素，就将该元素对应下标的值转为负数即可。

再次遍历时，返回第一个大于0值的数对应的下标。

ps：真的很爱这种费脑子但是不费代码的题………………………………

### No42 接雨水

**思路记录：**

首先，按照列来求能够接的雨水量，即每次求的都是当前列下能够接的雨水的量，求得方法是求当前列左右两端的最高的柱子，然后再求这两个最高柱子的较矮的一端，如果较矮的一端高于当前列的高度，那么当前列下能就是较矮的一端减去当前列的高度（只有这种情况可以接到）。

至于如何求两端的最高柱子，思路是动态规划。

### No48 旋转图像

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 **原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**我的思路：**（跑起来很慢……但是我觉得很好） 先把数组的每一行都翻转过来，再把数组中心对称过来，难点就是找到一个元素中心对称的元素的下标。nums(i,j)中心对称的元素下标为nums(n-1-j,n-1-i)，其中n为矩阵的行数/列数，并且处于对角线上的元素满足i+j=n-1。



### No53 最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 
```

**总体思路：**动态规划；

循环，每次更新以当前值为结尾的最大和值，判断的条件为，如果当前sum>0，则当前sum = sum + nums[i]，否则，当前sum = nums[i]，原因：

将nums[i]看作数a，a加一个负数不可能比本身还大，所以在sum小于0时，当前最大sum值为a即可。

根本想不到…………还是太笨了。。。。

### No54 螺旋矩阵

输入一个数组，要求按照顺时针螺旋顺序输出数组中的内容。

**思路记录：**分别设置矩阵的上，下，左，右边界。每遍历一个边界就更新当前方向上的边界。具体遍历的顺序根据要求来设置。例如，顺时针螺旋则为上（从左到右遍历）、右（从上到下遍历）、下（从右到左遍历）、左（从下往上遍历）。

### No55跳跃游戏  

**思路：**动态规划，k用于保留当前能到达的最远距离，k要和当前的下标i+nums[i]进行比较，如果当前k小于当前下表，则返回false。

### No56 合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**思路：** 首先将二维数组按照区间的首个元素排序，然后用一个list/新数组来保存结果，遍历整个数组，比较当前元素的左区间值和当前list中的最后一个元素的右区间值。

### No73 矩阵置零

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **原地** 算法**。** 

**思路记录：**

设置一个行数组和列数组，用来标记当前行/列中是否有元素为0，然后遍历数组，如果有元素为0，则将当前所在行以及列对应的行数组和列数组设置为true，遍历完之后再遍历一次，如果当前元素对应的行数组或者列数组为True，则将其值设置为0。

### No76 最小覆盖字串

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

```
示例 1：
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
示例 2：
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**思路记录：**

总体思路：滑动窗口；

用left和right两个指针维护一个滑动窗口，首先由右指针向右移动，并设置两个数组记录s和t中每个遍历到的字符的个数，并设置一个count值来记录当前窗口中存在的t中的字符总数，即只记录当前窗口中在t中出现的字符数，并且只有当前字符在t中存在且数量大于等于t中出现的次数时才执行递增，当count值等于t的长度时，则说明当前窗口存在所有t中的字符且数量不少于t中每个字符的个数。此时移动左指针，并维护此时的最小子串，当count再次不符合要求时，再次移动右指针。

直到右指针移动到字符串的结尾，则结束循环。

### No80 删除有序数组中的重复项 II

```
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。
```

**思路：**

我的思路：

设置一个count变量来记录每个元素的个数，并设置双指针，设置i，j，j用来遍历整个数组，i用来定位即将被覆盖的元素的位置，当j处的值和i处的不同时，需要替换，但是要保证上一个数的数量小于等于两个，所以要比较上一个数的count和2的大小，选出其中最小的值作为i要移动的位点数，然后将i+m的位置赋值为j。

### No88 合并两个有序数组

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

**思路：**

两个有序数组n1和n2，那么两个数组中最大的数一定是n1[m-1]或者n2[n-1],此时还需要定位到n1[n1.len-1],所以每次循环需要比较n1[m-1]和n2[n-1]，二者哪个大就放到数组最后一位。假设i=n1.len-1，那么其实就是每次循环比较m和n位置处对应数组的大小，并和n1的i处进行交换。

### No121 买卖股票的最佳时机 

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**思路：**动态规划，要维持两个变量，max和minP，分别代表当前的最大利润（小于0时记录为0）和当前的最小价格。

### No122 买卖股票的最佳时机 II  

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
     
思路：动态规划，需要一个二维数组来保存每一步的状态, dp[i][j]代表第i天持股状态为j时手上拥有的现金数，其中j=0代表手上是现金，j=1代表手上是股票，dp[i][0]需要和上一天的dp[i-1][1]加上当天的股价来比较，dp[i][1]需要和上一天dp[i-1][0]减去当天的股价来比较。
```

### No160 相交链表

**思路：** 重点在于找到A表和B表相差的节点数，只要能让两个表排除相差的节点的位置开始遍历，则走相同的步数就可以找到相交节点，方法就是A，B表同时遍历，当A表到结尾，则将其转到B表头，B表同理，然后直到二者相遇。（理解不了就画个图走一遍就知道了）

### No169 多数元素

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。 

```
输入：nums = [3,2,3]
输出：3

输入：nums = [2,2,1,1,1,2,2]
输出：2
```

**思路：**

该题的目的是找出该数组中的众数，而题目下的众数一定满足大于等于该数组中元素数量的1/2，把每个数想象成一个人，现在要进行投票，首先以第一个元素为基准，往后遍历时，只要和该元素相等，则count++，如果不是则count--，直到count为0，将res设置为下一个值，可以确定的是，众数的count一定不会为0，最后的返回的结果也是到最后count不为0的数对应的值。

### No189 轮转数组（旋转数组）

**提示：**翻转三次数组。

### No206 反转链表（不带头节点/就地反转）

需要设置两个指针，分别为cur以及next，cur代表当前遍历的元素，next代表当前遍历元素的下一个元素。需要保证每次遍历后反转当前cur元素为已经遍历过的所有元素中的第一个元素。

ps：带头节点和不带头节点链表的区别其实很简单，带头节点的链表初始化：cur=head.next，不带头节点的链表初始化：cur=head。

### No234 回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。 

**思路：**首先找到链表的中间结点，然后反转后半部分链表，如果链表满足回文链表，则反转后的链表的值和前半部分相同，同时遍历前半部分链表和后半部分链表，如果值不同则返回false。



### No238 除自身以外数组的乘积  

ps:不得使用除法

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**思路：**每一个元素对应的“除自身以外数组的乘积  ”可以分解为当前元素的左边所有元素的乘积乘以当前元素右边所有元素的乘积。

​           所以需要两个数组L[]和R[]分别保存每个元素的左边所有乘积和右边的所有乘积。

​           计算L[i]和R[i]时，需要分别遍历两次，用动态规划的思想，L[0]=1,R[len-1]=1,然后其余L[i]=L[i-1]*nums[i-1]。R[i]的计算类似。

### No239 滑动窗口最大值

题目：给定一个数组和窗口值，从头开始滑动窗口，每次都计算当前窗口中的最大值，并将所有最大值放到数组中返回。

思路记录：

总体思路：单调队列（自定义的队列），使该队列能够每次移除的元素为当前窗口中的最大值。注意不能使用优先队列来实现，因为使用优先队列会打乱原本数组中的顺序。

**实现方法，使用双端队列来实现：**

1.首先生成初始窗口；

2.每遍历初始窗口后的一个元素，则要删除不在当前窗口中的元素，当然这个元素可能在队列中，也可能已经被删除了，只需要判断当前队首的元素值是否等于当前下标的前k个值是否相同即可。

2.每次向队列中加元素时，要保证当前加入后的队列降序排列，如果当前队列的队尾元素小于当前即将加入的值，则需要在队列中移除之前所有小于当前值的元素，再加入。

3.然后取当前队列的首元素，也就是当前窗口的最大值。

### No 240 搜索二维矩阵

编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**我的思路：** 从矩阵的最下面开始向左或者向上回溯（递归），当前遍历到的元素一定是“以当前元素为右下角”的矩阵的最大值。思路没问题，但是超时了……………………………………

**正确思路：**从矩阵的(0，n-1)开始遍历，如果当前元素大于target，则指针向左移动，否则指针向下移动。

### No274 H 指数  

```
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```

**思路：**

应该先把数组排序，再又大到小进行判断，从最大引用次数对应的论文作为第一篇，并设置h=1，以此类推，往后的论文引用次数必须大于等于其论文次序才可以增加h的值。

### No438 找到字符串中所有字母异位词

总体思路：滑动窗口

思路记录：

维持一个和字符串p长度的窗口，然后在s中移动，判断是否为异位词的标准就是，该窗口中每个字母出现的个数都等于p字符串中每个字符出现的次数。而每个字母的字数，则需要创建一个长度为26的整数数组来保存。

### No560 和为K的子数组

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 k 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**思路记录：**

暴力枚举，两层循环，每遍历一个数，就枚举当前数以及其之前的所有值的和，如果和为k，则结果加一。

枚举算法：https://www.cnblogs.com/Gaowaly/p/16988439.html

## 链表相关

### No2 两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**要点：**保存两数之和的新的链表需要首先创建一个带有头节点的链表，并将其next置为空！

### No19 删除链表的倒数n个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。 

**要点：**要先给链表加一个头节点，从头结点开始遍历！！！

### No21 合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。  

**要点：**保存新的升序链表的新链表也需要创建一个带有头节点的链表，并将其next置空！



